`timescale 10ps / 10ps

`default_nettype none

module ddsx2 (
    input  wire logic [32-1:0] i_phase_inc,
    input  wire logic          i_phase_inc_valid,
    output      logic [36-1:0] o_cosine_data,
    output      logic [36-1:0] o_sine_data,
    output      logic [36-1:0] o_cosine_delay_data,
    output      logic [36-1:0] o_sine_delay_data,
    input       logic          i_ready,
    input  wire logic          i_clock,
    input  wire logic          i_reset
);

// Phase increment
logic [32-1:0] phase_inc_reg;
logic [32-1:0] phase_accum;
logic [32-1:0] phase_accum_delay;

always_ff @ (posedge i_clock) begin
    // Read input phase increment
    if (i_phase_inc_valid == 1'b1) begin
        phase_inc_reg <= i_phase_inc;
    end
    // Increment phase whenever an output is requested
    if (i_reset == 1'b1) begin
        phase_accum <= '0;
        phase_accum_delay <= phase_inc_reg;
    end else if (i_ready == 1'b1) begin
        phase_accum <= phase_accum + {phase_inc_reg, 1'b0};
        phase_accum_delay <= phase_accum_delay + {phase_inc_reg, 1'b0};
    end
end

// Sine/Cosine Look Up Table
localparam integer WIDTH = 36;
localparam integer RESIDUAL_WIDTH = WIDTH-{{ lut_width }};

logic signed [WIDTH-1:0]      cosine_reg0 /* synthesis syn_ramstyle="block_ram" */;
logic signed [WIDTH-1:0]      sine_reg0 /* synthesis syn_ramstyle="block_ram" */;
// logic [16+RESIDUAL_WIDTH-1:0] residual_reg0;

pmi_ram_dp_true #(
    .pmi_addr_depth_a = {{ 2**lut_width }},
    .pmi_addr_width_a = {{ lut_width }},
    .pmi_data_width_a = 2*WIDTH,
    .pmi_addr_depth_b = {{ 2**lut_width }},
    .pmi_addr_width_b = {{ lut_width }},
    .pmi_data_width_b = 2*WIDTH,
    .pmi_regmode_a = "reg",
    .pmi_regmode_b = "reg",
    .pmi_gsr = "disable",
    .pmi_resetmode = "sync",
    .pmi_optimization = "speed",
    .pmi_init_file = "ddsx2_sincos.txt",
    .pmi_init_file_format = "binary",
    .pmi_write_mode_a = "normal",
    .pmi_write_mode_b = "normal",
    .pmi_family = "ECP5U",
    .module_type = "pmi_ram_dp_true")


  (input [(pmi_data_width_a-1):0]   DataInA,
   input [(pmi_data_width_b-1):0]   DataInB,
   input [(pmi_addr_width_a-1):0] AddressA,
   input [(pmi_addr_width_b-1):0] AddressB,
   input  ClockA,
   input  ClockB,
   input  ClockEnA,
   input  ClockEnB,
   input  WrA,
   input  WrB,
   input  ResetA,
   input  ResetB,
   output [(pmi_data_width_a-1):0]  QA,
   output [(pmi_data_width_b-1):0]  QB)/*synthesis syn_black_box */;

// Pipeline Stage 0
always_ff @ (posedge i_clock) begin
    if (i_ready == 1'b1) begin
        // Perform table look up
        case(phase_accum[32-1:32-{{ lut_width }}]){% for lvalue in lut_values %}{% if lvalue != lut_values[-1] %}
        {{ lvalue }}: begin{% endif %}{% if lvalue == lut_values[-1] %}
        default: begin{% endif %}
            cosine_reg0 <= 36'sb{{ cos_values[lvalue] }};
            sine_reg0   <= 36'sb{{ sin_values[lvalue] }};
        end{% endfor %}
        endcase
        // Compute residual (value not obtained from table * 2*pi) // unsigned mult okay
        // residual_reg0 <= phase_accum[32-{{ lut_width }}-1:0] * 16'b{{ two_pi }};
    end
end

// Perform Correction
logic signed [WIDTH-1:0]                cosine_reg1;
logic signed [WIDTH-1:0]                sine_reg1;
// logic signed [RESIDUAL_WIDTH-1:0]       residual_reg1;

logic signed [WIDTH-1:0]                cosine_reg2;
logic signed [WIDTH-1:0]                sine_reg2;

always_ff @ (posedge i_clock) begin
    if (i_ready == 1'b1) begin
        // Pipeline Stage 1
        cosine_reg1 <= cosine_reg0;
        sine_reg1 <= sine_reg0;
        // residual_reg1 <= (residual_reg0[{{ lut_width }}+RESIDUAL_WIDTH-1:{{ lut_width - 1 }}] + 1'b1) >> 1;
        // Pipeline Stage 2
        cosine_reg2 <= cosine_reg1;
        sine_reg2 <= sine_reg1;

        // Pipeline Stage 3
        o_cosine_data <= cosine_reg2;
        o_sine_data <= sine_reg2;
    end
end

endmodule: ddsx2

`default_nettype wire
